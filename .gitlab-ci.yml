stages:
  - ssh_gen
  - plan
  - apply
  - debug
  - ansible
  - destroy

variables:
  TERRAFORM_VERSION: 1.5.7
  #TF_STATE_BUCKET: remote_terraform_state2"
  #TF_STATE_OBJECT: tf_state.tfstate
 # GCP_PROJECT_ID: $GCP_PROJECT_ID
  #GCP_SERVICE_ACCOUNT_KEY: $GCP_SERVICE_ACCOUNT_KEY  # Set this as a GitLab CI/CD secret variable
  

gen_ssh_key:
  image: bash:latest
  stage: ssh_gen
  script:
    - apk update && apk add openssh-client
    - mkdir .keys && cd ./.keys
    - ssh-keygen -f vm_keys -q -t rsa -N "" && echo "Keys successfully generated"
    - pwd
    - ls -R
  artifacts:
    name: "ssh-keys"
    expire_in: "1 day"
    paths:
      - .keys
      - ls -R

.provision_job:
  dependencies : [gen_ssh_key]
  script:
    #- echo GCP_SERVICE_ACCOUNT_KEY > gcp_key.json
    - pwd
    - ls -R
    - gcloud auth activate-service-account --key-file=gcp_key.json --project=terrafor4gcp
    - apk update && apk upgrade
    - apk install unzip
    - apk install wget
    - wget -O terraform.zip https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_386.zip
    - unzip terraform.zip && mv ./terraform /bin
    - terraform -version
    
   # - gsutil mb -p proud-curve-399517 -c STANDARD -l us-central1 gs://$TF_STATE_BUCKET/

     
    - >
        terraform init 
       # -backend-config="bucket=${TF_STATE_BUCKET}" 
       # -backend-config="prefix=${TF_STATE_OBJECT}" 
       # -backend-config="credentials=${GCP_SERVICE_ACCOUNT_KEY}"
      
dry_provision:
  image: alpine:3.18.2
  stage: plan
  dependencies: []  # No dependencies for this stage
  only:
    variables:
      - $CI_COMMIT_REF_NAME == "dev-ci"
  script:
    - !reference [.provision_job, script]
    - terraform validate
    - terraform plan

actual_provision:
  image: alpine:3.18.2
  stage: apply
  dependencies:
    - dry_provision  # Wait for 'dry_provision' stage to finish
  allow_failure: true
  only:
    variables:
      - $CI_COMMIT_REF_NAME == "dev-ci"
  script:
    - !reference [.provision_job, script]
     
    - terraform apply -auto-approve
    - sleep 30
    #- gcloud compute instances describe my-instance --zone=us-central1-b --format='value(networkInterfaces[0].networkIP)' > vm_ip.txt
    - gcloud compute instances describe my-instance --zone=us-central1-b --format='value(networkInterfaces[0].accessConfigs[0].natIP)' > vm_ip.txt


  artifacts:
    name: "vm_ip"
    expire_in: "1 day"
    paths:
      - 'vm_ip.txt'

debug_vm_ip:
    stage: debug
    script:
      - cat vm_ip.txt
    dependencies:
      - actual_provision
    
  
ansible_conf:
  image: python:3.9.17-slim-bullseye
  stage: ansible
  dependencies:
    - actual_provision  # Wait for 'actual_provision' stage to finish
  allow_failure: true
  only:
    variables:
      - $CI_COMMIT_REF_NAME == "dev-ci"
  script:
    
    - cat vm_ip.txt > vm_ip.txt
    - cat vm_ip.txt
    - chmod 750 ansible_files
    - cd ansible_files
    - apt-get update && apt-get install ansible -y
    - ansible --version
    - ansible-playbook install_nginx.yml
    #- ansible-playbook -i ../vm_ip.txt -e "ansible_ssh_private_key_file=../.keys/vm_keys" install_nginx.yml

dry_destroy_tf:
  image: google/cloud-sdk:latest
  stage: destroy
  dependencies: []  # No dependencies for this stage
  only:
    variables:
      - $CI_COMMIT_REF_NAME == "dev-ci"
  when: manual
  script:
    - !reference [.provision_job, script]
    - terraform plan -destroy

actual_destroy_tf:
  image: google/cloud-sdk:latest
  stage: destroy
  dependencies:
    - dry_destroy_tf  # Wait for 'dry_destroy_tf' stage to finish
  when: manual
  only:
    variables:
      - $CI_COMMIT_REF_NAME == "dev-ci"
  script:
    - !reference [.provision_job, script]
    - terraform destroy -auto-approve

